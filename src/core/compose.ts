import { existsSync, promises as fs } from 'node:fs'
import path from 'node:path'
import fg from 'fast-glob'
import { parseDirectives, stripDirectiveComments } from './directives'
import { discover } from './discovery'
import type { AgentsMdConfig, Fragment, Output } from './types'

const BANNER =
	'<!-- Generated by agents-md: DO NOT EDIT DIRECTLY. Edit *.agents.md fragments instead. Higher priority fragments appear first and win conflicts. -->'

async function loadFragment(
	file: string,
	cwd: string,
	seen: Set<string>,
): Promise<Fragment> {
	const abs = path.join(cwd, file)
	if (seen.has(abs)) {
		throw new Error(`circular import: ${abs}`)
	}
	seen.add(abs)
	try {
		const raw = await fs.readFile(abs, 'utf8')
		const directives = parseDirectives(raw)
		let content = stripDirectiveComments(raw)
		if (directives.imports) {
			const parts: string[] = []
			for (const imp of directives.imports) {
				const rel = imp.path.startsWith('@') ? imp.path.slice(1) : imp.path
				const resolved = path.resolve(path.dirname(abs), rel)
				try {
					const frag = await loadFragment(
						path.relative(cwd, resolved),
						cwd,
						seen,
					)
					parts.push(frag.content)
				} catch (err: unknown) {
					if ((err as NodeJS.ErrnoException)?.code === 'ENOENT') {
						console.warn(
							`missing import: ${path.relative(
								cwd,
								resolved,
							)} (referenced in ${file}:${imp.line})`,
						)
						continue
					}
					throw err
				}
			}
			parts.push(content)
			content = parts.join('\n')
		}
		return { path: file, content, directives }
	} finally {
		seen.delete(abs)
	}
}

function resolveTarget(
	fragment: Fragment,
	cwd: string,
	config: AgentsMdConfig,
): string {
	const dir = path.dirname(path.join(cwd, fragment.path))
	const target = fragment.directives.target
	if (target === 'root') return path.join(cwd, 'AGENTS.md')
	if (target && target !== 'nearest') {
		const targetDir = path.resolve(dir, target)
		return path.join(targetDir, 'AGENTS.md')
	}
	// nearest
	let current = dir
	while (true) {
		const candidate = path.join(current, 'AGENTS.md')
		if (existsSync(candidate)) return candidate
		const parent = path.dirname(current)
		if (parent === current) break
		current = parent
	}
	return config.defaultTarget === 'nearest'
		? path.join(dir, 'AGENTS.md')
		: path.join(cwd, 'AGENTS.md')
}

export async function compose(
	config: AgentsMdConfig & { cwd?: string } = {},
): Promise<Output[]> {
	const cwd = config.cwd ?? process.cwd()
	const files = await discover(cwd, config)
	const fragments: Fragment[] = []
	for (const file of files) {
		const frag = await loadFragment(file, cwd, new Set())
		fragments.push(frag)
	}
	const groups = new Map<string, Fragment[]>()
	for (const frag of fragments) {
		const target = resolveTarget(frag, cwd, config)
		if (!groups.has(target)) groups.set(target, [])
		const arr = groups.get(target)
		arr?.push(frag)
	}
	const outputs: Output[] = []
	const written = new Set<string>()
	for (const [target, frags] of groups) {
		frags.sort(
			(a, b) =>
				(b.directives.priority ?? 0) - (a.directives.priority ?? 0) ||
				a.path.localeCompare(b.path),
		)
		const lines = [BANNER]
		const sources: Output['sources'] = []
		for (const frag of frags) {
			const segment: string[] = []
			if (config.annotateSources !== false) {
				const p = frag.directives.priority ?? 0
				segment.push(`<!-- source: ${frag.path} priority=${p} -->`)
			}
			segment.push(frag.content.trim())
			if (config.annotateSources !== false) {
				segment.push(`<!-- /source: ${frag.path} -->`)
			}
			lines.push(segment.join('\n'))
			sources.push({ path: frag.path, chars: Array.from(frag.content).length })
		}
		let content = `${lines.join('\n\n')}\n`
		if (config.truncate?.atChars) {
			const limit = config.truncate.atChars
			const chars = Array.from(content)
			if (chars.length > limit) {
				if (config.truncate.strategy === 'middle') {
					const half = Math.floor(limit / 2)
					content = `${chars.slice(0, half).join('')}â€¦${chars.slice(-half).join('')}`
				} else {
					content = chars.slice(0, limit).join('')
				}
			}
		}
		await fs.mkdir(path.dirname(target), { recursive: true })
		const existing = existsSync(target)
			? await fs.readFile(target, 'utf8')
			: null
		if (existing !== content) {
			await fs.writeFile(target, content)
		}
		outputs.push({
			path: path.relative(cwd, target),
			chars: Array.from(content).length,
			sources,
		})
		written.add(target)
	}
	const existing = await fg('**/AGENTS.md', {
		cwd,
		ignore: config.exclude ?? ['**/node_modules/**', '**/.git/**'],
		dot: true,
	})
	for (const rel of existing) {
		const abs = path.join(cwd, rel)
		if (written.has(abs)) continue
		let prev: string | null = null
		try {
			prev = await fs.readFile(abs, 'utf8')
		} catch {
			// ignore
		}
		if (prev?.startsWith(BANNER)) {
			const content = `${BANNER}\n`
			if (prev !== content) {
				await fs.writeFile(abs, content)
			}
			outputs.push({
				path: rel,
				chars: Array.from(content).length,
				sources: [],
			})
		}
	}
	return outputs
}
