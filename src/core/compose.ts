import { existsSync, promises as fs } from 'node:fs'
import path from 'node:path'
import { parseDirectives, stripDirectiveComments } from './directives'
import { discover } from './discovery'
import type { AgentsMdConfig, Fragment, Output } from './types'

const BANNER = '<!-- Generated by agents-md: DO NOT EDIT DIRECTLY -->'

async function loadFragment(
	file: string,
	cwd: string,
	seen: Set<string>,
): Promise<Fragment> {
	const abs = path.join(cwd, file)
	if (seen.has(abs)) {
		throw new Error(`circular import: ${abs}`)
	}
	seen.add(abs)
	const raw = await fs.readFile(abs, 'utf8')
	const directives = parseDirectives(raw)
	let content = stripDirectiveComments(raw)
	if (directives.imports) {
		const parts: string[] = []
		for (const imp of directives.imports) {
			const rel = imp.startsWith('@') ? imp.slice(1) : imp
			const resolved = path.resolve(path.dirname(abs), rel)
			const frag = await loadFragment(path.relative(cwd, resolved), cwd, seen)
			parts.push(frag.content)
		}
		parts.push(content)
		content = parts.join('\n')
	}
	seen.delete(abs)
	return { path: file, content, directives }
}

function resolveTarget(
	fragment: Fragment,
	cwd: string,
	config: AgentsMdConfig,
): string {
	const dir = path.dirname(path.join(cwd, fragment.path))
	const target = fragment.directives.target
	if (target === 'root') return path.join(cwd, 'AGENTS.md')
	if (target && target !== 'nearest') {
		const targetDir = path.resolve(dir, target)
		return path.join(targetDir, 'AGENTS.md')
	}
	// nearest
	let current = dir
	while (true) {
		const candidate = path.join(current, 'AGENTS.md')
		if (existsSync(candidate)) return candidate
		const parent = path.dirname(current)
		if (parent === current) break
		current = parent
	}
	return config.defaultTarget === 'nearest'
		? path.join(dir, 'AGENTS.md')
		: path.join(cwd, 'AGENTS.md')
}

export async function compose(
	config: AgentsMdConfig & { cwd?: string } = {},
): Promise<Output[]> {
	const cwd = config.cwd ?? process.cwd()
	const files = await discover(cwd, config)
	const fragments: Fragment[] = []
	for (const file of files) {
		const frag = await loadFragment(file, cwd, new Set())
		fragments.push(frag)
	}
	const groups = new Map<string, Fragment[]>()
	for (const frag of fragments) {
		const target = resolveTarget(frag, cwd, config)
		if (!groups.has(target)) groups.set(target, [])
		const arr = groups.get(target)
		arr?.push(frag)
	}
	const outputs: Output[] = []
	for (const [target, frags] of groups) {
		frags.sort(
			(a, b) =>
				(a.directives.weight ?? 0) - (b.directives.weight ?? 0) ||
				a.path.localeCompare(b.path),
		)
		const lines = [BANNER]
		const sources: Output['sources'] = []
		for (const frag of frags) {
			if (config.annotateSources !== false) {
				lines.push(`<!-- source: ${frag.path} -->`)
			}
			lines.push(frag.content.trim())
			sources.push({ path: frag.path, bytes: Buffer.byteLength(frag.content) })
		}
		const content = `${lines.join('\n\n')}\n`
		await fs.mkdir(path.dirname(target), { recursive: true })
		await fs.writeFile(target, content)
		outputs.push({
			path: path.relative(cwd, target),
			bytes: Buffer.byteLength(content),
			sources,
		})
	}
	return outputs
}
