import { expect, test } from 'bun:test'
import { promises as fs } from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import { compose } from '../src/core/compose'

test('compose fragments into targets', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-'))
	await fs.writeFile(path.join(tmp, 'snippet.md'), 'Snippet')
	await fs.writeFile(
		path.join(tmp, 'intro.agents.md'),
		'<!-- agents-md: import=@./snippet.md -->\nIntro',
	)
	await fs.mkdir(path.join(tmp, 'sub/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'sub/agents-md/part.md'), 'Sub part')
	await fs.writeFile(path.join(tmp, 'sub/AGENTS.md'), '')

	const outputs = await compose({ cwd: tmp })
	expect(outputs.length).toBe(2)
	const root = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(root.split('\n')[0]).toBe(
		'<!-- Generated by agents-md. Edit source fragments and run agents-md compose. -->',
	)
	expect(root).toContain('<!-- source: intro.agents.md -->')
	expect(root).toContain('Snippet')
	expect(root).toContain('Intro')
	const sub = await fs.readFile(path.join(tmp, 'sub/AGENTS.md'), 'utf8')
	expect(sub).toContain('Sub part')
})

test('composes multiple AGENTS.md with scoped content', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-multi-'))
	await fs.writeFile(path.join(tmp, 'root.agents.md'), 'Root')
	await fs.mkdir(path.join(tmp, 'a/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'a/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'a/agents-md/a.md'), 'A')
	await fs.mkdir(path.join(tmp, 'b/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'b/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'b/agents-md/b.md'), 'B')
	await fs.mkdir(path.join(tmp, 'b/nested/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'b/nested/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'b/nested/agents-md/n.md'), 'N')

	const outputs = await compose({ cwd: tmp })
	expect(outputs.length).toBe(4)
	expect(new Set(outputs.map((o) => o.path)).size).toBe(4)
	const root = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(root).toMatch(/\nRoot\n/)
	expect(root).not.toMatch(/\nA\n/)
	expect(root).not.toMatch(/\nB\n/)
	expect(root).not.toMatch(/\nN\n/)
	const a = await fs.readFile(path.join(tmp, 'a/AGENTS.md'), 'utf8')
	expect(a).toMatch(/\nA\n/)
	expect(a).not.toMatch(/\nB\n/)
	const b = await fs.readFile(path.join(tmp, 'b/AGENTS.md'), 'utf8')
	expect(b).toMatch(/\nB\n/)
	expect(b).not.toMatch(/\nN\n/)
	const nested = await fs.readFile(path.join(tmp, 'b/nested/AGENTS.md'), 'utf8')
	expect(nested).toMatch(/\nN\n/)
})

test('config include/exclude/includeFiles options', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-config-'))
	await fs.writeFile(path.join(tmp, 'a.txt'), 'A')
	await fs.writeFile(path.join(tmp, 'b.agents.md'), 'B')
	await fs.writeFile(path.join(tmp, 'c.agents.md'), 'C')
	await compose({
		cwd: tmp,
		include: ['**/*.txt', '**/*.agents.md'],
		exclude: ['**/b.agents.md'],
		includeFiles: ({ path: p }) => !p.endsWith('c.agents.md'),
	})
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toMatch(/\nA\n/)
	expect(out).not.toMatch(/\nB\n/)
	expect(out).not.toMatch(/\nC\n/)
})

test('defaultTarget nearest creates AGENTS.md beside fragment', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-nearest-'))
	await fs.mkdir(path.join(tmp, 'nested'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'nested/a.agents.md'), 'X')
	const outputs = await compose({ cwd: tmp, defaultTarget: 'nearest' })
	expect(outputs.map((o) => o.path)).toEqual(['nested/AGENTS.md'])
	const list = await fs.readdir(tmp)
	expect(list).not.toContain('AGENTS.md')
})

test('defaultTarget root and annotateSources disabled', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-root-'))
	await fs.mkdir(path.join(tmp, 'nested'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'nested/a.agents.md'), 'X')
	const outputs = await compose({
		cwd: tmp,
		defaultTarget: 'root',
		annotateSources: false,
	})
	expect(outputs.map((o) => o.path)).toEqual(['AGENTS.md'])
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toContain('X')
	expect(out).not.toContain('<!-- source:')
})

test('missing imports warn with file and line', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-missing-'))
	await fs.writeFile(
		path.join(tmp, 'main.agents.md'),
		'<!-- agents-md: import=@./missing.md -->\nMain',
	)
	const warnings: string[] = []
	const orig = console.warn
	console.warn = (msg) => warnings.push(String(msg))
	await compose({ cwd: tmp })
	console.warn = orig
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toContain('Main')
	expect(warnings).toContain(
		'missing import: missing.md (referenced in main.agents.md:1)',
	)
})

test('fragments without directives compose without warnings', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-nodir-'))
	await fs.writeFile(path.join(tmp, 'plain.agents.md'), 'Just text')
	const warnings: string[] = []
	const orig = console.warn
	console.warn = (msg) => warnings.push(String(msg))
	await compose({ cwd: tmp })
	console.warn = orig
	expect(warnings).toEqual([])
})

test('compose does not rewrite unchanged outputs', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-idem-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A')
	await compose({ cwd: tmp })
	const first = await fs.stat(path.join(tmp, 'AGENTS.md'))
	await compose({ cwd: tmp })
	const second = await fs.stat(path.join(tmp, 'AGENTS.md'))
	expect(second.mtimeMs).toBe(first.mtimeMs)
})
