import { expect, test } from 'bun:test'
import { promises as fs } from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import { compose } from '../src/core/compose'
import { summarize } from '../src/core/report'

test('compose fragments into targets', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-'))
	await fs.writeFile(path.join(tmp, 'snippet.md'), 'Snippet')
	await fs.writeFile(
		path.join(tmp, 'intro.agents.md'),
		'<!-- agents-md: import=@./snippet.md -->\nIntro',
	)
	await fs.mkdir(path.join(tmp, 'sub/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'sub/agents-md/part.md'), 'Sub part')
	await fs.writeFile(path.join(tmp, 'sub/AGENTS.md'), '')

	const outputs = await compose({ cwd: tmp })
	expect(outputs.length).toBe(2)
	const root = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(root.split('\n')[0]).toBe(
		'<!-- Generated by agents-md: DO NOT EDIT DIRECTLY. Edit *.agents.md fragments instead. Higher priority fragments appear first and win conflicts. -->',
	)
	expect(root).toContain('<!-- source: intro.agents.md priority=0 -->')
	expect(root).toContain('<!-- /source: intro.agents.md -->')
	expect(root).toContain('Snippet')
	expect(root).toContain('Intro')
	const sub = await fs.readFile(path.join(tmp, 'sub/AGENTS.md'), 'utf8')
	expect(sub).toContain('Sub part')
})

test('composes multiple AGENTS.md with scoped content', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-multi-'))
	await fs.writeFile(path.join(tmp, 'root.agents.md'), 'Root')
	await fs.writeFile(path.join(tmp, 'AGENTS.md'), '')
	await fs.mkdir(path.join(tmp, 'a/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'a/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'a/agents-md/a.md'), 'A')
	await fs.mkdir(path.join(tmp, 'b/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'b/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'b/agents-md/b.md'), 'B')
	await fs.mkdir(path.join(tmp, 'b/nested/agents-md'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'b/nested/AGENTS.md'), '')
	await fs.writeFile(path.join(tmp, 'b/nested/agents-md/n.md'), 'N')
	await fs.mkdir(path.join(tmp, 'c/nested'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'c/nested/c-nested.agents.md'), 'C')

	const outputs = await compose({ cwd: tmp })
	expect(outputs.length).toBe(4)
	expect(new Set(outputs.map((o) => o.path)).size).toBe(4)
	const root = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(root).toMatch(/\nRoot\n/)
	expect(root).toMatch(/\nC\n/)
	expect(root).not.toMatch(/\nA\n/)
	expect(root).not.toMatch(/\nB\n/)
	expect(root).not.toMatch(/\nN\n/)
	const a = await fs.readFile(path.join(tmp, 'a/AGENTS.md'), 'utf8')
	expect(a).toMatch(/\nA\n/)
	expect(a).not.toMatch(/\nB\n/)
	const b = await fs.readFile(path.join(tmp, 'b/AGENTS.md'), 'utf8')
	expect(b).toMatch(/\nB\n/)
	expect(b).not.toMatch(/\nN\n/)
	const nested = await fs.readFile(path.join(tmp, 'b/nested/AGENTS.md'), 'utf8')
	expect(nested).toMatch(/\nN\n/)
})

test('config include/exclude/includeFiles options', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-config-'))
	await fs.writeFile(path.join(tmp, 'a.txt'), 'A')
	await fs.writeFile(path.join(tmp, 'b.agents.md'), 'B')
	await fs.writeFile(path.join(tmp, 'c.agents.md'), 'C')
	await compose({
		cwd: tmp,
		include: ['**/*.txt', '**/*.agents.md'],
		exclude: ['**/b.agents.md'],
		includeFiles: ({ path: p }) => !p.endsWith('c.agents.md'),
	})
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toMatch(/\nA\n/)
	expect(out).not.toMatch(/\nB\n/)
	expect(out).not.toMatch(/\nC\n/)
})

test('adding include globs picks up existing files', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-include-'))
	await fs.mkdir(path.join(tmp, 'docs'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'docs/guide.md'), 'Guide')
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A')
	await compose({ cwd: tmp })
	let out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).not.toContain('Guide')
	await compose({
		cwd: tmp,
		include: ['**/agents-md/**/*.md', '**/*.agents.md', '**/docs/**/*.md'],
	})
	out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toContain('Guide')
})

test('higher priority surfaces earlier', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-priority-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A')
	await fs.writeFile(
		path.join(tmp, 'b.agents.md'),
		'<!-- agents-md: priority=5 -->\nB',
	)
	await compose({ cwd: tmp })
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out.indexOf('B')).toBeLessThan(out.indexOf('A'))
	expect(out).toContain('priority=5')
})

test('defaultTarget nearest creates AGENTS.md beside fragment', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-nearest-'))
	await fs.mkdir(path.join(tmp, 'nested'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'nested/a.agents.md'), 'X')
	const outputs = await compose({ cwd: tmp, defaultTarget: 'nearest' })
	expect(outputs.map((o) => o.path.replace(/\\/g, '/'))).toEqual([
		'nested/AGENTS.md',
	])
	const list = await fs.readdir(tmp)
	expect(list).not.toContain('AGENTS.md')
})

test('defaultTarget root and annotateSources disabled', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-root-'))
	await fs.mkdir(path.join(tmp, 'nested'), { recursive: true })
	await fs.writeFile(path.join(tmp, 'nested/a.agents.md'), 'X')
	const outputs = await compose({
		cwd: tmp,
		defaultTarget: 'root',
		annotateSources: false,
	})
	expect(outputs.map((o) => o.path)).toEqual(['AGENTS.md'])
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toContain('X')
	expect(out).not.toContain('<!-- source:')
	expect(out).not.toContain('<!-- /source:')
})

test('missing imports warn with file and line', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-missing-'))
	await fs.writeFile(
		path.join(tmp, 'main.agents.md'),
		'<!-- agents-md: import=@./missing.md -->\nMain',
	)
	const warnings: string[] = []
	const orig = console.warn
	console.warn = (msg) => warnings.push(String(msg))
	await compose({ cwd: tmp })
	console.warn = orig
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out).toContain('Main')
	expect(warnings).toContain(
		'missing import: missing.md (referenced in main.agents.md:1)',
	)
})

test('fragments without directives compose without warnings', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-nodir-'))
	await fs.writeFile(path.join(tmp, 'plain.agents.md'), 'Just text')
	const warnings: string[] = []
	const orig = console.warn
	console.warn = (msg) => warnings.push(String(msg))
	await compose({ cwd: tmp })
	console.warn = orig
	expect(warnings).toEqual([])
})

test('compose does not rewrite unchanged outputs', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-idem-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A')
	await compose({ cwd: tmp })
	const first = await fs.stat(path.join(tmp, 'AGENTS.md'))
	await compose({ cwd: tmp })
	const second = await fs.stat(path.join(tmp, 'AGENTS.md'))
	expect(second.mtimeMs).toBe(first.mtimeMs)
})

test('stale outputs are cleared when fragments removed', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-stale-'))
	const frag = path.join(tmp, 'a.agents.md')
	await fs.writeFile(frag, 'A')
	await compose({ cwd: tmp })
	await fs.unlink(frag)
	const outputs = await compose({ cwd: tmp })
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(outputs.length).toBe(1)
	expect(out).toBe(
		'<!-- Generated by agents-md: DO NOT EDIT DIRECTLY. Edit *.agents.md fragments instead. Higher priority fragments appear first and win conflicts. -->\n',
	)
})

test('truncate oversized outputs', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-trunc-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A'.repeat(200))
	const outputs = await compose({
		cwd: tmp,
		annotateSources: false,
		truncate: { atChars: 100 },
	})
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(outputs[0].chars).toBe(100)
	expect(Array.from(out).length).toBe(100)
	expect(out.includes('A'.repeat(18))).toBe(false)
})

test('truncate oversized outputs with middle strategy', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-trunc-mid-'))
	await fs.writeFile(
		path.join(tmp, 'a.agents.md'),
		'abcdefghijABCDEFGHIJ'.repeat(10),
	)
	const outputs = await compose({
		cwd: tmp,
		annotateSources: false,
		truncate: { atChars: 120, strategy: 'middle' },
	})
	const out = await fs.readFile(path.join(tmp, 'AGENTS.md'), 'utf8')
	expect(out.startsWith('<!-- Generated by agents-md:')).toBe(true)
	expect(out).toContain('â€¦')
	expect(out.trimEnd().endsWith('FGHIJ')).toBe(true)
	expect(outputs[0].chars).toBe(121)
})

test('limits flag oversized sources and outputs', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-limits-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A'.repeat(60))
	const outputs = await compose({ cwd: tmp, annotateSources: false })
	const summary = summarize(outputs, {
		limits: { warnOutputChars: 100, maxSourceChars: 50 },
	})
	expect(summary.limits).toBeDefined()
	expect(
		summary.limits?.details.some((d) => d.includes('AGENTS.md exceeds warn')),
	).toBe(true)
	expect(
		summary.limits?.details.some((d) => d.includes('a.agents.md exceeds max')),
	).toBe(true)
	expect(summary.limits?.violated).toBe(true)
})

test('limits warn on sources and fail on outputs', async () => {
	const tmp = await fs.mkdtemp(path.join(os.tmpdir(), 'agents-md-limits2-'))
	await fs.writeFile(path.join(tmp, 'a.agents.md'), 'A'.repeat(60))
	const outputs = await compose({ cwd: tmp, annotateSources: false })
	const summary = summarize(outputs, {
		limits: { warnSourceChars: 40, maxOutputChars: 50 },
	})
	expect(summary.limits).toBeDefined()
	expect(
		summary.limits?.details.some((d) => d.includes('a.agents.md exceeds warn')),
	).toBe(true)
	expect(
		summary.limits?.details.some((d) => d.includes('AGENTS.md exceeds max')),
	).toBe(true)
	expect(summary.limits?.violated).toBe(true)
})
